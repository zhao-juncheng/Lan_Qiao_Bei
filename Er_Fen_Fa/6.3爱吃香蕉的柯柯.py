class Solution:
    '''
    问题分析：
        1、找到一个最小的速度 k
        2、结合题目，想要应用二分法来查找 k ，则需确定 k 的取值范围
            2.1、因为每小时只能吃完一堆香蕉，所以，k = speed[1,max(piles)],max(piles)即香蕉最多的
                一堆它的香蕉的个数
            2.2、l , h 为 speed 的两个定位指针，分别为一左一右，用于二分区间得到区间的 mid
            2.3、若在 speed[mid] 处，speed[mid]的速度在 H 小时内可以吃完，则更新右边界 h = mid
                找到更小的速度 k ，直到找到最小的速度 k
            2.4、若在 speed[mid] 处，吃不完，则速度太慢了，则更新左边界 l = mid +1
    '''
    def minEatingSpeed(self,piles,H):

        # -----------------------------------------------------------------------------
        # 这是一个辅助函数
        # 注意，这是在函数中定义的一个局部函数
        def help(k):
            '''
            计算以当前的速度 k 吃香蕉，能否在 H 小时内吃完
            k:int,柯柯吃香蕉的速度
            return:bool,能在 H 小时内吃完则返回 True
            '''
            
            t = 0 # 计算柯柯吃完全部香蕉所需的时间 t
            for pile in piles :
                #t += ( pile - 1 ) // k + 1 # 这个计算方式更简便，下面的计算方式看起来更细节
                
                if pile % k == 0 :
                    t += pile // k
                else :
                    t += pile // k + 1
            return t <= H
        # ------------------------------------------------------------------------------

        # ------------------------------------------------------------------------------
        '''
        找到在 H 小时内吃完所有香蕉的最小速度 k
        piles:List[int],有 n 堆香蕉，piles中存放了每堆香蕉的个数。
        H:int,限定的一个时间
        return:int,最小速度 k , 若没有找到，则返回 -1
        '''
        l , h = 1 , max(piles) # 二分查找的查找空间，此处是[柯柯吃香蕉的速度区间]
        while l <= h:
            mid = l + ( h - l ) // 2 # ( h - l) // 2 = l + ( h - l ) // 2
            if l == h :
                return l
            elif help(mid):
                h = mid
            else :
                l = mid + 1
        return -1
        # ------------------------------------------------------------------------------

s = Solution() # 实例化一个Solution对象

piles = [30,11,23,4,20] # 测试数据一，答案为 30
h = 5
print(s.minEatingSpeed(piles,h))

piles = [3,6,7,11] # 测试数据二，答案为 4
h = 8
print(s.minEatingSpeed(piles,h))
